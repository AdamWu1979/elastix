\documentclass[]{report}

% Define page
\usepackage[top=1in, bottom=1in, left=1.5in, right=1.5in]{geometry}
\linespread{1.1}

% For math
\usepackage{amsmath,amsthm,amssymb}
\usepackage{bm,url}

% For figures
\usepackage{graphicx,subfigure,psfrag}

\usepackage{natbib}

% Definitions
\newcommand{\elastix}{\texttt{elastix}}
\newcommand{\transformix}{\texttt{transformix}}
\newcommand{\vx}{\bm{x}}
\newcommand{\vu}{\bm{u}}
\newcommand{\vux}{\bm{u}(\bm{x})}
\newcommand{\vmu}{\bm{\mu}}
\newcommand{\vT}{\bm{T}}
\newcommand{\vTx}{\bm{T}(\bm{x})}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Manual for \elastix}
\author{Stefan Klein and Marius Staring}
%\date{}
\maketitle

\setcounter{page}{1} \pagenumbering{roman} \tableofcontents
%\newpage
%\listoffigures
%\newpage
%\listoftables
\newpage
\pagenumbering{arabic} \setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% main text

\chapter{Introduction}\label{chp:Introduction}

This manual describes a software package for image registration:
\elastix. The software consists of a collection of algorithms that
are commonly used to solve medical image registration problems.
The modular design of \elastix\ allows the user to quickly test
and compare different registration methods for his/her specific
application. The command-line interface simplifies the processing
of large amounts of data sets, using scripting.

Chapter~\ref{chp:Registration} discusses some general theory of
image registration. Also, the different components of which a
registration method consists are treated. In
Chapter~\ref{chp:elastix}, \elastix\ is described and its usage is
explained. Chapter~\ref{chp:transformix} is dedicated to
\transformix, a program accompanying \elastix\. A tutorial is
given in Chapter~\ref{chp:Tutorial}, including many
recommendations based on the authors' own experiences.
Chapter~\ref{chp:develop} provides more details about the source
code and explains how to create extensions of \elastix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Image registration}\label{chp:Registration}

Image registration is an important tool in the field of medical
imaging. In many clinical situations several images of a patient are
made in order to analyse the patient’s situation. These images are
acquired with, for example, X-ray scanners, Magnetic Resonance
Imaging (MRI) scanners, Computed Tomography (CT) scanners, and
Ultrasound scanners, which provide knowledge about the anatomy of the
subject. Combination of patient data, mono- or multi-modal, often
yields additional clinical information not apparent in the separate
images. For this purpose, the spatial relation between the images has
to be found. Image registration is the task of finding a spatial
one-to-one mapping from voxels in one image to voxels in the other
image, see Figure \ref{fig:concept}. Good reviews on the subject are
given in \citet{HillEA01,LesterEA99,MaintzEA98}.

\begin{figure}
\centering
\includegraphics[width=8cm]{images/ImageRegistrationConcept.eps}
\caption{Image registration is the task of finding a spatial
transformation mapping one image to another. Adopted from
\citet{ITKSoftwareGuideSecondEdition}.} \label{fig:concept}
\end{figure}

In registration one image, what we call the \emph{moving image}
$I_M(\vx)$, is deformed to fit the other image, the \emph{fixed
image} $I_F(\vx)$. Registration is the problem of finding a
\emph{displacement} $\vux$ that makes $I_M(\vx + \vux)$ spatially
aligned to $I_F(\vx)$. An equivalent formulation is to say that
registration is the problem of finding a \emph{transformation}
$\vT(\vx) = \vx + \vux $ that makes $I_M(\vT(\vx))$ spatially aligned
to $I_F(\vx)$. The quality of alignment is defined by a distance or
similarity measure $\mathcal{S}$, such as the sum of squared
differences (SSD), the correlation ratio, or the mutual information
(MI) measure. Because this problem is ill-posed, a regularisation or
penalty term $\mathcal{P}$ is often introduced that constrains $\vT$.

Commonly, the registration problem is formulated as an optimisation
problem in which the cost function $\mathcal{C}$ is minimised w.r.t.
$\vT$:
\begin{align}
\hat \vT &= \arg \min_{\vT} \mathcal{C}(\vT; I_F,I_M), \qquad \text{with} \label{eq:registration1}\\
\mathcal{C}(\vT; I_F,I_M) &= -\mathcal{S}(\vT; I_F,I_M) + \gamma
\mathcal{P}(\vT),\label{eq:registration2}
\end{align}
where $\gamma$ weighs similarity against regularity. To solve the
above minimisation problem, there are basically two approaches:
parametric and nonparametric. The reader is referred to
\cite{Fis04:Unified} for an overview on nonparametric methods.
Nonparametric methods are further not discussed in this manual.
The \elastix\ software is based on the parametric approach. In
parametric methods, the number of possible transformations is
limited by introducing a parameterisation (model) of the
transformation. The original optimisation problem becomes thus:
\begin{align}
\hat \vT_{\vmu} &= \arg \min_{\vT_{\vmu}}
 \mathcal{C}(\vT_{\vmu} ; I_F,I_M), \label{eq:towardsparametric}
\end{align}
where the subscript $\vmu$ indicates that the transform has been
parameterised. The vector $\vmu$ contains the values of the
``transformation parameters''. For example, when the
transformation is modelled as a 2D rigid transformation, the
parameter vector $\vmu$ contains one rotation angle and the
translations in $x$ and $y$ direction. We may write Equation
(\ref{eq:towardsparametric}) also as:
\begin{align}
\hat\vmu &= \arg \min_{\vmu} \mathcal{C}(\vmu; I_F,I_M).
\label{eq:parametric}
\end{align}
From this equation it becomes clear that the original problem
(\ref{eq:registration1}) has been simplified. Instead of
optimising over a ``space of functions $\vT$'', we now optimise
over the three elements of $\vmu$. Examples of other
transformation models are given in
Section~\ref{sec:comp:transform}.

From the basic registration problem formulated as in Equation
(\ref{eq:registration1}) and (\ref{eq:registration2}), several
components can be recognised. First, we have the similarity measure
$\mathcal{S}$ that defines the quality of alignment. These metrics
are discussed in Section \ref{sec:comp:metric}. Second, the
transformation model $\vT$ that defines the spatial relation, see
Section. Third, the optimisation procedure to actually solve the
problem, see Section \ref{sec:comp:optimiser}. Then, during the
optimisation the value $I_M(\vTx)$ is evaluated at non-voxel
positions, for which intensity interpolation is needed, see Section
\ref{sec:comp:interpolator}. Another thing, not immediately clear
from Equation (\ref{eq:registration1}) and (\ref{eq:registration2}),
is the use of multi-resolution strategies to speed-up registration,
and to make it more robust, see Section
\ref{sec:comp:multiresolution}. The regularisation term $\mathcal{P}$
is not discussed in this manual.

\section{Images}

Since image registration is all about images, we have to be
careful with what is meant by an image. We adopt the notion of an
image from the Insight Toolkit \citep[p.
40]{ITKSoftwareGuideSecondEdition}:

\begin{quote}
Additional information about the images is considered mandatory.
In particular the information associated with the physical spacing
between pixels and the position of the image in space with respect
to some world coordinate system are extremely important. Image
origin and spacing are fundamental to many applications.
Registration, for example, is performed in physical coordinates.
Improperly defined spacing and origins will result in inconsistent
results in such processes. Medical images with no spatial
information should not be used for medical diagnosis, image
analysis, feature extraction, assisted radiation therapy or image
guided surgery. In other words, medical images lacking spatial
information are not only useless but also hazardous.

Figure \ref{fig:image} illustrates the main geometrical concepts
associated with the itk::Image. In this figure, circles are used
to represent the centre of pixels. The value of the pixel is
assumed to exist as a Dirac Delta Function located at the pixel
centre. Pixel spacing is measured between the pixel centres and
can be different along each dimension. The image origin is
associated with the coordinates of the first pixel in the image. A
pixel is considered to be the rectangular region surrounding the
pixel centre holding the data value. This can be viewed as the
Voronoi region of the image grid, as illustrated in the right side
of the figure. Linear interpolation of image values is performed
inside the Delaunay region whose corners are pixel centres.
\end{quote}

\begin{figure}
\centering
\includegraphics[width=12cm]{images/ImageOriginAndSpacing.eps}
\caption{Geometrical concepts associated with the ITK image.
Adopted from \citet{ITKSoftwareGuideSecondEdition}.}
\label{fig:image}
\end{figure}

Therefore, you should take care that you use an image format that
is able to store the relevant information (e.g. mhd, DICOM).

\section{Metrics}\label{sec:comp:metric}

Several choices for the similarity measure can be found in the
literature. The three most common choices are the Sum of Squared
Differences (SSD), the Normalised Correlation Coefficient (NCC), and
the Mutual Information measure (MI).

\begin{description}
\item[Sum of Squared Differences:] The SSD is defined as:
\begin{align}
\mathrm{SSD}(\vT;I_F,I_M) &= \frac{1}{N} \sum_{i=0}^N \left(
I_F(\vx_i) - I_M(\vT(\vx_i)) \right)^2,\label{eq:ssd}
\end{align}
with $N$ the number of voxels in the fixed image. Given an
transformation $\vT$, this measure can easily be implemented by
looping over the voxels in the fixed image, taking $I_F(\vx_i)$,
calculating $I_M(\vT(\vx_i))$ by interpolation, and adding the
squared difference to the sum.

\item[Normalised Correlation Coefficient:] The NCC is defined as:
\begin{align}
\mathrm{NCC}(\vT;I_F,I_M) &= \frac{ \sum_{i=0}^N \left( I_F(\vx_i) -
\overline{I_F} \right) \left( I_M(\vT(\vx_i)) - \overline{I_M}
\right) }{ \sqrt{\sum_{i=0}^N \left( I_F(\vx_i) - \overline{I_F}
\right)^2 \sum_{i=0}^N \left( I_M(\vT(\vx_i)) - \overline{I_M}
\right)^2} },\label{eq:ncc}
\end{align}
with $\overline{I_F}$ and $\overline{I_M}$ the average grey-value of
$I_F(\vx)$ and $I_M(\vT(\vx))$, respectively.

\item[Mutual Information:] For MI \citep{MaesEA97,ViolaEA97,MattesEA03} we
use a definition given by \citet{ThevenazEA00a}:
\begin{align}
\mathrm{MI}(\vT; I_F, I_M) &= \sum\limits_{\iota \in L_M}
\sum\limits_{\kappa \in L_F} p(\iota, \kappa; \vT) \log_2 \left(
\frac{ p(\iota, \kappa; \vT) }{ p_F(\kappa) p_M(\iota; \vT) }
\right),\label{eq:MI}
\end{align}
where $L_F$ and $L_M$ are the sets of histogram bin centres of the
fixed and moving image, respectively, $p$ is the joint discrete
probability, and $p_F$ and $p_M$ are the marginal discrete
probabilities. The probabilities are modelled with B-spline Parzen
windows.
\end{description}

The SSD measure is a measure that is only suited for two images with
an equal intensity distribution, i.e. for images from the same
modality. NCC is less strict, it assumes a linear relation between
the intensity values of the fixed and moving image, and can therefore
be used more often. The MI measure is the most general of the three:
only a relation between the probability distributions of the
intensities of the fixed and moving image is assumed. For the mutual
information measure it is well-known that it is suited not only for
mono-modal, but also for multi-modal image pairs. This measure is
your first choice for image registration.

\section{Transforms}\label{sec:comp:transform}

The flexibility of the transformation $\vT$ determines how much
deformation between the fixed and moving image you can handle. From
less flexibility to more we list the translation, the rigid
transformation, the affine, and finally the so-called
\emph{non-rigid} transformation. The last category covers a fast
amount of transformations, all capable to model local deformations.

\begin{description}
\item[Translation:] The translation is defined as:
\begin{align}
\vTx &= \vx + \bm{t},
\end{align}
with $\bm{t}$ a vector.

\item[Rigid:] A rigid transformation is defined as:
\begin{align}
\vTx &= R \vx + \bm{t},
\end{align}
with the matrix $R$ a rotation matrix, so it is orthonormal and
proper.

\item[Affine:] An affine transformation is defined as:
\begin{align}
\vTx &= A \vx + \bm{t},
\end{align}
where the matrix $A$ has no restrictions.

\item[B-splines:] For the category of non-rigid transformations, we focus on a
transformation that is parameterised by B-splines
\citep{RueckertEA99}. In 2D:
\begin{align}
\vT_i(\vx) &= \vx_i + \sum_{l \in V_{\vx}} \mu_{li} \beta^3(x_1 -
x_{l1}) \beta^3(x_2 - x_{l2}), \qquad \forall i \in
\{1,2\},\label{eq:bspline}
\end{align}
with $\vx = (x_1,x_2)$, $\beta^3(x)$ the cubic B-spline polynomial
\citep{Unser99}, $\mu_{li}$ the B-spline coefficients, and $V_{\vx}$
the set of all control points within the compact support of the
B-spline at $\vx$. In this context we talk about `the control point
grid that is put on the fixed image', and about `control points that
are moved around'. The control point grid is defined by the amount of
space between the control points, which can be different for each
direction. B-splines have local support, which is beneficial both for
modelling local transformations, and for fast computation. See Figure
\ref{fig:bspline} for an illustration of the use of B-splines in
image registration.
\end{description}

\begin{figure}
\centering
\subfigure[]{\includegraphics[width=4.5cm,height=4.5cm]{images/fixed.eps}}\label{sfig:bspline:a}
\subfigure[]{\includegraphics[width=4.5cm,height=4.5cm]{images/moving.eps}}\label{sfig:bspline:b}
\subfigure[]{\includegraphics[width=4.5cm,height=4.5cm]{images/deformed.eps}}\label{sfig:bspline:c}
\caption{B-spline transformation. (a) the fixed image. (b) the
moving image with the B-spline grid overlayed. (c) the control points
are moved around until $I_M(\vTx)$ resembles $I_F(\vx)$. The new
deformed B-spline grid defines the deformed image.}
\label{fig:bspline}
\end{figure}

The attentive reader will notice that in Figure \ref{fig:bspline} the
B-spline grid is depicted on top of the moving image, instead of the
fixed image as stated above. This brings us to a technicality
concerning the \emph{implementation} of transformations. If a
transformation would be implemented by a so-called forward-transform,
then points from the moving image would be mapped to the fixed image
domain. However, when it comes to creating the deformed image
$I_M(\vTx)$, possibly, due to the nature of a nonrigid
transformation, none of the voxels in $I_M$ maps to a point $\bm{y}$
in the domain of $I_F$. This would result in a `gap' in the deformed
image. To avoid this, transformations are implemented using a
backward-transform. The transformation maps from the fixed image
domain to the moving image domain, and therefore the B-spline grid is
actually (`in the code') put on the fixed image.

Choose the transformation that fits your needs: only choose a
nonrigid transformation if you expect that the underlying problem
contains local deformations, choose a rigid transformation if you
only need to compensate for differences in pose. To initialise a
nonrigid registration problem, perform a rigid or affine one first.

\section{Optimisers}\label{sec:comp:optimiser}

\begin{figure}
\centering
\includegraphics[width=5cm]{images/Gradient_descent.eps}
\caption{Iterative optimisation. The arrows indicate the steps
$a_k \bm{d}_k$ taken in the direction of the optimum, which is in the
centre.} \label{fig:optimisation}
\end{figure}

To solve the optimisation problem \ref{eq:registration1}, i.e. to
obtain the optimal transformation $\vT$, commonly an iterative
optimisation strategy is employed:
\begin{align}
\vmu_{k+1} &= \vmu_k + a_k \bm{d}_k, \quad k = 0, 1, 2, \cdots,
\end{align}
with $\bm{d}_k$ the `search direction' at iteration $k$, $a_k$ a
scalar gain factor controlling the step size along the search
direction, and $\vmu_k$ the parameters that define the
transformation. For example, for rigid registration the parameter
vector $\vmu$ is of size 6 in 3D: the three Euler angles and the
three translations, and for B-splines this parameters vector contains
the set of B-spline coefficients ($\mu$ in Equation
(\ref{eq:bspline}). The optimisation process is illustrated in Figure
\ref{fig:optimisation}. \citet{KleinEA07} give an overview of various
optimisation routines the literature offers. Examples are
quasi-Newton (QN), nonlinear conjugate gradient (NCG), gradient
descent (GD), and Robbins-Monro (RM).

\begin{description}
\item[Gradient descent:] Gradient descent optimisation methods take the
search direction as the negative gradient of the cost function:
\begin{align}
\vmu_{k+1} &= \vmu_k - a_k \bm{g}(\vmu_k),\label{eq:gd}
\end{align}
with $\bm{g}(\vmu_k) = \partial \mathcal{C} / \partial \vmu$
evaluated at the current position $\vmu_k$. Several choices exist for
the gain factor $a_k$, such as a determined by a line search or
defined by a decaying function of $k$, e.g.:
\begin{align}
a_k &= \frac{a}{(k+A)^{\alpha}},\label{eq:gain}
\end{align}
where $a > 0$, $A \ge 1$, and $0 \le \alpha \le 1$ are user-defined
constants. \cite{Spall98} suggests the use of $\alpha = 0.602$ and
$A$ approximately 10\% of the user-defined maximum number of
iterations, or less. The choice of the overall gain, $a$, depends on
the expected ranges of $\vmu$ and $\bm{g}$ and is thus problem
specific.

\item[Robbins-Monro:] The RM optimisation method replace the calculation of
the derivative of the cost function $\bm{g}(\vmu_k)$ by an
approximation $\widetilde{\bm{g}}_k$.
\begin{align}
\vmu_{k+1} &= \vmu_k - a_k \widetilde{\bm{g}}_k,\label{eq:RM}
\end{align}
The approximation is potentially faster to compute, but might
deteriorate convergence properties of the GD scheme.
\citet{KleinEA07} showed that using only a small random subset of
voxels from the fixed image accelerates registration significantly,
without compromising registration accuracy. It is important that a
new subset of fixed image voxels is selected every iteration $k$, so
that the approximation error has zero mean.
\end{description}

For details on other optimisation methods we refer to
\citep{KleinEA07,NocedalEA99}.

We recommend the use of RM over GD, since it is so much faster,
without compromising on accuracy. In that case the parameter $a$ is
parameter that is to be tuned for your application.

\section{Interpolators}\label{sec:comp:interpolator}

As stated above, during the optimisation the value $I_M(\vTx)$ is
evaluated at non-voxel positions, for which intensity interpolation
is needed. Several methods for interpolation exist, varying in
quality and speed. Some examples are given in Figure
\ref{fig:interpolation}.

\begin{description}
\item[Nearest neighbour:] This is the most simple technique, low in
quality, requiring little resources. The intensity of the nearest
voxel is returned.

\item[Linear:] Still very simple. The returned value is a weighted
average of the surrounding voxels, with the distance to each voxel
taken as weight.

\item[$N$-th order B-spline:] The higher the order, the better the
quality, but also requiring more computation time. See
\citet{Unser99} for more details.
\end{description}

During registration a first order B-spline interpolation, i.e. linear
interpolation, often gives satisfactory results. It is a good
trade-off between quality and speed. To generate the final result,
i.e. the deformed result of the registration, a higher order
interpolation is usually required, for which we recommend $N=3$.

\begin{figure}
\centering
\subfigure[]{\includegraphics[width=2.5cm]{images/nn.eps}}\label{sfig:interpolation:nn}
\subfigure[]{\includegraphics[width=2.5cm]{images/linear.eps}}\label{sfig:interpolation:lin}
\subfigure[]{\includegraphics[width=2.5cm]{images/bs2.eps}}\label{sfig:interpolation:bs2}
\subfigure[]{\includegraphics[width=2.5cm]{images/bs3.eps}}\label{sfig:interpolation:bs3}
\subfigure[]{\includegraphics[width=2.5cm]{images/bs5.eps}}\label{sfig:interpolation:bs5}
\caption{Interpolation. (a) nearest neighbour, (b) linear, (c) B-spline $N=2$,
(d) B-spline $N=3$, (e) B-spline $N=5$.} \label{fig:interpolation}
\end{figure}

\section{Multi-resolution}\label{sec:comp:multiresolution}

For a good overview of multi-resolution strategies see
\citet{LesterEA99}. Part of this section is taken from the paper with
minor modifications. Two hierarchical methods are distinguished:
reduction of data complexity, and reduction of transformation
complexity.

\subsection{Data complexity}

``To reduce the number of local optima, initially the information
content within the images to be matched is reduced, so that only the
coarsest, most global structures remain. The absence of finer detail
ensures avoidance of local minima traps by virtue of their
eradication. Ideally the optimisation surface initially contains only
one maximum, in the region of the optimal global match. The
optimisation can then be improved by gradual reintroduction of
structural details at the same rate in both the images and the
concurrent updating of the registering deformation to match
corresponding re-introduced structures or features.''

``Such hierarchies of decreasing data complexity are provided by
scale spaces, where the image size is constant in all levels, or by
pyramids, where image size is also reduced in each successive level.
In the latter case, an additional advantage for pixel-based matching
schemes is that computation of optimal parameters is speeded up in
the higher level (lower resolution) images due to the reduction in
the amount of data to be processed.''

Several scale spaces or pyramids are found in the literature, amongst
others Gaussian and Laplacian pyramids, morphological scale space,
and spline and wavelet pyramids. The Gaussian pyramid is the most
common one, and we have used it all our papers.

\begin{figure}
\centering
\subfigure[]{\includegraphics[width=5cm]{images/moving_pd.eps}}\label{sfig:mres:1}
\subfigure[]{\includegraphics[width=2.5cm]{images/res2_2.eps}}\label{sfig:mres:2}
\subfigure[]{\includegraphics[width=1.25cm]{images/res1_4.eps}}\label{sfig:mres:bs3}
\caption{Multi-resolution with a Gaussian pyramid.} \label{fig:multiresolution}
\end{figure}

\subsection{Transformation complexity}

``The second hierarchical method is to increase the complexity of the
transformation within a particular algorithm.''

This is also typically used in registration, if only a rigid
registration is performed prior to nonrigid registration. Also for
the nonrigid registration part we often, but not always, apply this
technique. Registration is then started with a coarse B-spline grid,
only capable of modelling coarse deformations. In subsequent
resolutions the B-spline grid is gradually refined, thereby
introducing the capability to match smaller structures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\elastix}\label{chp:elastix}

\section{Introduction}

The development of \elastix\ started half to late 2003, and was
intended to facilitate our registration research. After some initial
versions we decided to put the separate components of \elastix\ in
separate libraries. This resulted in major version 3.0 in November
2004. \elastix\ 3.0 was also the first version that was made publicly
available on the \elastix\ website, around the same time. The
continued development brings us today (December 2007) to version 3.8.

\begin{tabular}{l|l}
what & where \\
\hline
website        & \texttt{http://www.isi.uu.nl/Elastix} \\
CVS repository & \texttt{/shared/CVS/elastix/} (hosted at the ISI) \\
WIKI           & \texttt{https://wiki.isi.uu.nl/bin/view/CADweb/ElastiX} \\
FAQ            & \texttt{https://wiki.isi.uu.nl/bin/view/CADweb/ElastixFAQ}
\end{tabular}

The website also contains a
doxygen\footnote{\texttt{www.doxygen.org}} generated part that
provides documentation of the source code. An overview of all
available classes can be found at
\begin{quote}
\texttt{www.isi.uu.nl/Elastix/doxygen/classes.html}.
\end{quote}
For each class a description of this class is given, together with
information on how to use it in \elastix. See
\begin{quote}
\texttt{www.isi.uu.nl/Elastix/doxygen/modules.html}
\end{quote}
for an overview of all available components.


\section{How to call \elastix}

\elastix\ is a command line program. This means that you have to open
a command line interface (a DOS-box, a shell) and type in an
appropriate elastix command. This also means that there is no
graphical user interface. Help on using the program can be acquired
as follows:
\begin{quote}
\texttt{elastix --help}
\end{quote}
which will give a list of mandatory and optional arguments. The most
basic command to run a registration is as follows:
\begin{quote}
\texttt{elastix -f fixedImage.ext -m movingImage.ext -out
outputDirectory -p parameterFile.txt}
\end{quote}
where `\texttt{ext}' is the extension of the image files. The above
arguments are mandatory. These are minimally needed to run \elastix.
All output of \elastix\ is written to the output directory, which
needs to be created before running \elastix. The output consists of a
log file (\texttt{elastix.log}), and optionally the resulting
registered image (\texttt{result.?.mhd}), the parameters of the
transformation that relate the fixed and the moving image
(\texttt{TransformParameters.?.txt}). The parameter file is an
important file: in it is defined, in normal text, what kind of
registration is performed (i.e. what metric, optimizer, etc.) and
what the parameters are that define the registration. It gives a high
amount of flexibility and control over the process. More information
about the parameter file is given in Section \ref{sec:elastix:param}.

The use of masks is supported. They can be provided by adding
\texttt{-fMask fixedMask.ext} and/or \texttt{-mMask movingMask.ext}
to the command line. An initial transformation can be provided with a
valid transform parameter file by adding \texttt{-t0
TransformParameters.txt} to the command line. With the command line
option \texttt{-threads unsigned\_int} the user can specify the
maximum number of threads that \elastix\ will use.

On the \elastix\-website, in the `About' section, you can find an
example on how to use the program. Maybe now is the time to try the
example and see a registration in action.

Running multiple registrations in succession, each possibly of a
different type, and with the output of a previous registration as
input to the next, can be done with \elastix\ in several ways. The
first one is to run \elastix\ once with the first registration, and
use its output (the \texttt{TransformParameter.0.txt} that can be
found in the output directory) as input for a new run of \elastix\
with the command line argument \texttt{-t0}. So:
\begin{quote}
\texttt{elastix -f ... -m ... -out out1 -p param1.txt} \\
\texttt{elastix -f ... -m ... -out out2 -p param2.txt -t0
out1/TransformParameters.0.txt} \\
\texttt{elastix -f ... -m ... -out out3 -p param3.txt -t0
out2/TransformParameters.0.txt}
\end{quote}
and so on. Another possibility is combine the registrations with one
run of \elastix:
\begin{quote}
\texttt{elastix ... -p param1.txt -p param2.txt -p param3.txt}
\end{quote}
The transformations from each of the registrations are automatically
combined.

\section{General code layout}

\section{The parameter file}\label{sec:elastix:param}

The parameter file is a text file that defines the components of the
registration and their parameter values. Supplying a parameter works
as follows:
\begin{quote}
\texttt{(ParameterName value(s))}
\end{quote}
So parameters are provided between brackets, first the name, followed
by one or more values. If the value if of type string then the values
need to be quoted: \texttt{(ParameterName "value1" ... "valueN")}. If
the values are of floating type, then at least one value behind the
comma need to be given: \texttt{(ParameterName 1.3 3.0)}. Comments
can be provided by adding `\texttt{//}' before a line. A minimal
example of a valid parameter file is given in Appendix \ref{chp:ExampleParam}.
A list of available parameters for each class is given at
\texttt{www.isi.uu.nl/Elastix/doxygen/parameter.html}.

Since the choice of the several components and the parameter values
define the registration, it is very important to set them wisely.
These choices is what makes the registration a success or a disaster.
Therefore, a separate chapter is dedicated to the fine art of tuning
a registration, see Chapter \ref{chp:Tutorial}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\transformix}\label{chp:transformix}

\section{Introduction}

By now you are able to at least run a registration, by calling
\elastix\ correctly. It is often also useful to apply the
transformation as found by the registration to another image. Maybe
you want to apply the transformation to an original larger image to
gain resolution. Or maybe you need the transformation to apply it to
an atlas image. For those purposes a program called \transformix\ is
available. It was developed simultaneously with \elastix.

\section{How to call \transformix}

Like \elastix\, \transformix is a command line driven program. You
can get basic help on how to call it, by:
\begin{quote}
\texttt{transformix --help}
\end{quote}
which will give a list of mandatory and optional arguments. The most
basic command is as follows:
\begin{quote}
\texttt{transformix -in inputImage.ext -out outputDirectory -tp
TransformParameters.txt}
\end{quote}
This call will transform the input image and write it, together with
a log file, to the output directory. The transformation you want to
apply is defined in the so-called transform parameter file, see
Section \ref{sec:transformix:tp}. If you want to deform a set or all
points, the appropriate call is:
\begin{quote}
\texttt{transformix -ipp inputPoints.txt -out outputDirectory -tp
TransformParameters.txt} \\
\texttt{transformix -ipp all -out outputDirectory -tp
TransformParameters.txt}
\end{quote}
This will create a file the deformed output points or a deformation
field vector image. With the command line option \texttt{-threads
unsigned\_int} the user can specify the maximum number of threads
that \transformix\ will use.

\section{Details}

The run-time of \transformix is built up of the following parts:

1. computing the b-spline decomposition 2. computing the deformation
for each voxel 3. interpolating the input image for each voxel.

I'm not sure, but I guess step 2 is the most time-consuming task, in
case of a B-spline deformation. For a nD B-spline deformation,
computing the deformation vector at a voxel basically amounts to n
interpolations.

Step 1. is avoided by using a linear interpolator of course.

Step 3 is faster when using linear interpolation instead of cubic
interpolation. I don't know how much exactly.

What is the complexity of FinalBSplineInterpolator? And of
FinalLinearInterpolator? In required operations per voxel. Is that
described in the docs, in some papers, or on the wiki?

Memory consumption, see the wiki

\section{The transform parameter file}\label{sec:transformix:tp}

The result of a registration is the transformation relating the fixed
and moving image. The parameters of this transformation are stored in
a \texttt{TransformParameters.?.txt}-file. An example of its
structure for a 2D rigid transformation is given in Appendix
\ref{chp:ExampleTransformParam}. The text file contains all
information necessary to resample an input image (the moving image)
to the region specified in the file (by default the fixed image
region).

The transform parameter file can be manually edited or created as is
convenient for the user. Multiple transformations are composed by
iteratively supplying another transform parameter file with the
\texttt{InitialTransformParametersFileName} tag.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tutorial}\label{chp:Tutorial}


\section{General advice}

When performing registration one carefully has to choose the several
components, as specified in Chapter \ref{chp:components}. In Table
\ref{table:recom:components} some recommendations are given.

\begin{table}
\centering
\begin{tabular*}{15cm}{@{\extracolsep{\fill}} p{3.5cm} | p{11cm} }
\textbf{Component} & \textbf{Recommendation} \\
\hline
Registration & \texttt{MultiResolutionRegistration}: Multiple image
resolutions is what you need, 3 or more is a good starting point. And
if you think you don't need all this multi-resolution, you can always
set the \texttt{NumberOfResolutions} to 1. \\
FixedImagePyramid & \texttt{FixedSmoothingImagePyramid}: this pyramid
will smooth, but not down-sample the fixed image for you, according
to the \texttt{FixedImageSchedule} you provide. If you only set the
\texttt{NumberOfResolutions}, a default schedule will be used that
down-samples the fixed image by 2. That schedule is usually fine. In
case you have highly anisotropic data, you might want to blur less in
the direction of the largest spacing. \\
MovingImagePyramid & See the FixedImagePyramid. \\
Metric    & \texttt{AdvancedMattesMutualInformation}: usually works
well, both for mono- and multi-modal images. It supports fast
computation of the metric value and derivative in case the transform
is a B-spline. \\
Optimizer & \texttt{StandardGradientDescent}: see Equations
(\ref{eq:gd}) and (\ref{eq:gain}). Offers the possibility to perform
fast registration, see \cite{KleinEA07}. The problem is to tune the
parameters of the gain factor $a_k$, see Section
\ref{sec:Tutorial:importantparam}. \\
Sampler & \texttt{RandomCoordinate}: works well in conjunction with
the \texttt{StandardGradientDescent} optimiser. Set the
\texttt{NumberOfSpatialSamples} to 3000. \\
Transform & Depends on the application. For rigid choose
\texttt{EulerTransform}, for affine \texttt{AffineTransform}, for
nonrigid registration problems \elastix\ has the
\texttt{BSplineTransform}. The latter requires setting the
\texttt{FinalGridSpacing}. Always start with a rigid or affine
transformation before doing a nonrigid one, to get a good initial
alignment. \\
Interpolator & \texttt{BSplineInterpolator}: first order is usually
enough during the registration: \texttt{(BSplineInterpolationOrder
1)}. \\
ResampleInterpolator & \texttt{FinalBSplineInterpolator}: the
interpolator that is used for generating the resulting deformed
moving image. We recommend a third order B-spline for this:
\texttt{(FinalBSplineInterpolationOrder 3)}.
\end{tabular*}
\caption{Some recommendations for the several components.}\label{table:recom:components}
\end{table}

\section{Important parameters}\label{sec:Tutorial:importantparam}

\begin{description}
\item[On multi-resolution:] Two parameters have to be set to define
the multi-resolution strategy: the number of resolutions and the
specific down-sampling schedule that is used in each resolution.

In general 3 resolutions is a good starting point. If the fixed and
moving image are initially far away, you can increase the number of
resolution levels to, say, 5 or 6. This way the images are more
blurred and more attention is paid to register large, dominant
structures.

The pyramid schedule defines the amount of blurring, and
down-sampling in case of a FixedRecursiveImagePyramid is used, in
each direction $x,y,z$ and for each resolution level. It can be
specified as follows:
\begin{quote}
\texttt{(FixedImagePyramidSchedule 8 8 4 4 2 2 1 1)}
\end{quote}
In this example 4 resolutions for a 2D image are used. At resolution
level 0 the image is, possibly, downsampled by a factor 8 and blurred
with $\sigma = 8/2$ voxels in each direction. At level 1 a factor 4
is used, and finally at the last level, level 4, the original images
are used for registration. Specifying the fixed and moving image
pyramids with an identical schedule can be done with one command,
e.g.:
\begin{quote}
\texttt{(ImagePyramidSchedule 4 4 2 2 2 1 1 1 1)}
\end{quote}
for a 3D image with 3 resolution levels, where less smoothing is
performed in the $z$-direction.

\item[On multi-grid:] The B-spline nonrigid transformation is defined
by a uniform grid of control points. This grid is defined by the
spacing between the grid nodes. The spacing defines how dense the
grid is, or what the locality is of the transformation you can model.
For each resolution level you can define a different grid spacing.
This is what we call multi-grid. In general, we recommend to start
with a coarse B-spline grid, i.e. a more global transformation. This
way first the larger structures are matched, for the same reason as
why you should start with a rigid or affine transformation. In later
resolutions you can refine the transformation in a stepwise fashion;
the idea is that you subsequently match smaller structures, up to the
final precision. The final grid spacing is specified with:
\begin{quote}
\texttt{(FinalGridSpacingInPhysicalUnits 10.0 10.0 10.0)}
\end{quote}
with as much numbers as there are dimensions in your image. The
spacing is in most medical images specified in millimetres. It is
also possible to specify the grid in voxel units:
\begin{quote}
\texttt{(FinalGridSpacingInVoxels 16.0 16.0 16.0)}
\end{quote}
If the final B-spline grid spacing is chosen high, then you cannot
match small structures. On the other hand, if the grid spacing is
chosen very low, then small structures can be matched, but you
possibly allow the transformation too have too much freedom. This can
result in irregular transformations, especially on homogenous parts
of your image, since there are no edges (or other information) at
such areas that can guide the registration. A penalty or
regularisation term, see Equation (\ref{eq:registration2}), can help
to avoid these problems. It is hard to recommend a value for the
final grid spacing, since it depends on the desired accuracy. But we
can try: if you are interested in somewhat larger structures, you
could set it too 32 voxels, for matching smaller structures you could
go down to 16 or 8 voxels, or even up to 4. The last choice will
maybe require some regularisation term, unless maybe if you have
carefully and gradually refined the grid spacing.

To specify a multi-grid schedule use the \texttt{GridSpacingSchedule}
command:
\begin{quote}
\texttt{(NumberOfResolutions 4)} \\
\texttt{(FinalGridSpacingInVoxels 8.0 8.0)} \\
\texttt{(GridSpacingSchedule 6.0 6.0 4.0 4.0 2.5 2.5 1.0 1.0)}
\end{quote}
In case of 2D images, this schedule specifies a grid spacing of $6
\times 8 = 48$ voxels in resolution level 0, via 32 and 20 voxels, to
8 voxels in the final resolution level.

As a side-note: the number of parameters that are minimised in
(\ref{eq:registration1}) is determined by the size of $\vmu$, i.e. in
case of the B-spline deformable transform by the control point grid
spacing. If you double the spacing, the number of parameters are
increased by a factor 8 for a 3D image. For a $256^3$ image and a
grid spacing of 16 voxels this will result in approximately
$(256/16)^3 \times 3 \approx 12.000$ parameters; for a grid spacing
of 8 voxels this is almost 100.000 parameters. The amount of
parameters is directly related to memory consumption and registration
time.

\item[On the sampler:] The recommended optimisation routine is the
\texttt{StandardGradientDescent} method. This method can be used with
a small amount of samples, randomly selected in every iteration, see
Section ???, which significantly decreases registration time. We
recommend:
\begin{quote}
\texttt{(ImageSampler "RandomCoordinate")} \\
\texttt{(NumberOfSpatialSamples 3000)}
\end{quote}
The first line selects a sampler that draws samples from the fixed
image. These samples are not necessarily on voxel locations (on the
voxel grid), but are mostly from points between voxels, so
interpolation is needed. This specific sampler avoids what is known
as the grid-effect [citations]. The second line specifies that 3000
samples are drawn, which is enough to get a convergence as fast as
using all samples, but of course with a significantly reduced
computation time per iteration.

\item[On the optimiser:] The \texttt{StandardGradientDescent} method
(\ref{eq:RM}) needs a choice for the step size $a_k$, which is in
\elastix\ defined as in Equation (\ref{eq:gain}). For the parameter
$\alpha$ we recommend the value 0.602. For $A$ use something in the
order of 50. This leaves the parameter $a$ as the most important
parameter to tune. If $a$ is set too high, the iterative solving
algorithm (\ref{eq:RM}) becomes unstable, and you may deform your
image beyond recognition. If $a$ is set too low, you will never make
it to the optimum, or may get stuck in a very small nearby local
optimum. Too complicate things further, a good choice for $a$ is
dependent on the cost function that is used for registration: the $a$
that will give you a good result for SSD is not the same as the one
that gives a good result for MI. Finally, $a$ also depends on the
amount of deformation that you expect between the fixed and the
moving image. So again, recommendations are hard to give. In general
we advise you to think in orders of magnitude, if $a = 10$ is too
small, try $a = 100$ and not $a = 11$. For mutual information you
could start around $a = 1000.0$. For the mean squared difference
metric you could try something smaller than 1 ???
\begin{quote}
\texttt{(SP\_a 1000.0 500.0 500.0)} \\
\texttt{(SP\_alpha 0.602)} \\
\texttt{(SP\_A 50.0)}
\end{quote}
$a$ equally large for every resolution level? or start with large
steps end with small steps?

number of iterations
\begin{quote}
\texttt{(MaximumNumberOfIterations 500)}
\end{quote}
which is not only the maximum, but also the minimum, since there is
no other appropriate stopping condition for this optimiser.

\end{description}


\section{Overview of all parameters}

A list of all parameters that can be specified for each registration
component can be found at the \elastix\ website:
\begin{quote}
\url{www.isi.uu.nl/Elastix/doxygen/parameter.html}
\end{quote}
At that site you can find how to specify a parameter and what the
default value is. We have tried to come up with sensible defaults,
although the defaults will not work in all cases.

\section{Masks}


\section{Trouble shooting}

initial alignment not good, rotation parameter scales, large steps,
multi-resolution

\subsection{Memory}

The typical size of clinical images increases as a function of time.
Therefore, memory efficiency will become more of an issue. What to do
with large images?
\begin{itemize}
\item Buy yourself a brand new computer with a lot of memory. Make
sure that this computer is 64 bit, otherwise you cannot address this
much memory. Also make sure that you operating system support 64 bit.

\item Images in \elastix\ are internally by default represented by as a bunch of
voxels of floating type. You can modify this to short images:
\begin{quote}
\texttt{(FixedInternalImagePixelType "short")} \\
\texttt{(MovingInternalImagePixelType "short")}
\end{quote}
This way you save half the amount of memory that is used to store the
fixed and moving images, and their multi-resolution pyramids. This
will come at the cost of a loss of precision, but may not be that
harmful.

\item
\end{itemize}


\section{Example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Developers guide}\label{chp:develop}

\section{Setup of the code}

\section{Creating new modules}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\chapter{Example parameter file}\label{chp:ExampleParam}

\begin{verbatim}
//ImageTypes
(FixedInternalImagePixelType "float")
(FixedImageDimension 2)
(MovingInternalImagePixelType "float")
(MovingImageDimension 2)

//Components
(Registration "MultiResolutionRegistration")
(FixedImagePyramid "FixedRecursiveImagePyramid")
(MovingImagePyramid "MovingRecursiveImagePyramid")
(Interpolator "BSplineInterpolator")
(Metric "AdvancedMattesMutualInformation")
(Optimizer "StandardGradientDescent")
(ResampleInterpolator "FinalBSplineInterpolator")
(Resampler "DefaultResampler")
(Transform "EulerTransform")

// ********** Pyramid

// Total number of resolutions
(NumberOfResolutions 3)


// ********** Transform

//(CenterOfRotation 128 128) center by default
(AutomaticTransformInitialization "true")
(HowToCombineTransforms "Compose")


// ********** Optimizer

// Maximum number of iterations in each resolution level:
(MaximumNumberOfIterations 300 300 600)

//SP: Param_a in each resolution level. a_k = a/(A+k+1)^alpha
(SP_a 0.001)

//SP: Param_alpha in each resolution level. a_k = a/(A+k+1)^alpha
(SP_alpha 0.602)

//SP: Param_A in each resolution level. a_k = a/(A+k+1)^alpha
(SP_A 50.0)


// ********** Metric

//Number of grey level bins in each resolution level:
(NumberOfHistogramBins 32)
(FixedKernelBSplineOrder 1)
(MovingKernelBSplineOrder 3)


// ********** Several

(WriteTransformParametersEachIteration "false")
(WriteTransformParametersEachResolution "false")
(ShowExactMetricValue "false")
(ErodeMask "true")


// ********** ImageSampler

//Number of spatial samples used to compute the mutual information in each resolution level:
(ImageSampler "RandomCoordinate")
(NumberOfSpatialSamples 2048)
(NewSamplesEveryIteration "true")


// ********** Interpolator and Resampler

//Order of B-Spline interpolation used in each resolution level:
(BSplineInterpolationOrder 1)

//Order of B-Spline interpolation used for applying the final deformation:
(FinalBSplineInterpolationOrder 3)

//Default pixel value for pixels that come from outside the picture:
(DefaultPixelValue 0)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Example transform parameter file}\label{chp:ExampleTransformParam}

\begin{verbatim}
(Transform "EulerTransform")
(NumberOfParameters 3)
(TransformParameters -0.000000 -4.564513 -2.091174)
(InitialTransformParametersFileName "NoInitialTransform")
(HowToCombineTransforms "Compose")

// Image specific
(FixedImageDimension 2)
(MovingImageDimension 2)
(FixedInternalImagePixelType "float")
(MovingInternalImagePixelType "float")
(Size 256 256)
(Index 0 0)
(Spacing 1.0000000000 1.0000000000)
(Origin 0.0000000000 0.0000000000)

// EulerTransform specific
(CenterOfRotationPoint 128.0000000000 128.0000000000)

// ResampleInterpolator specific
(ResampleInterpolator "FinalBSplineInterpolator")
(FinalBSplineInterpolationOrder 3)

// Resampler specific
(Resampler "DefaultResampler")
(DefaultPixelValue 0.000000)
(ResultImageFormat "mhd")
(ResultImagePixelType "short")
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\pagestyle{plain} \addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plainnat}
\bibliography{IEEEabrv,manual}

\end{document}
